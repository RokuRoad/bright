
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>


<link rel='stylesheet' href='https://unpkg.com/chevrotain@3.4.0/diagrams/diagrams.css'>

<script src='https://unpkg.com/chevrotain@3.4.0/diagrams/vendor/railroad-diagrams.js'></script>
<script src='https://unpkg.com/chevrotain@3.4.0/diagrams/src/diagrams_builder.js'></script>
<script src='https://unpkg.com/chevrotain@3.4.0/diagrams/src/diagrams_behavior.js'></script>
<script src='https://unpkg.com/chevrotain@3.4.0/diagrams/src/main.js'></script>

<div id="diagrams" align="center"></div>    

<script>
    window.serializedGrammar = [
  {
    "type": "Rule",
    "name": "Program",
    "orgText": "() => {\n            this.MANY(() => {\n                this.OR([\n                    { ALT: () => this.SUBRULE(this.FunctionDeclaration, Declaration) },\n                    { ALT: () => this.SUBRULE(this.LibraryStatement, Declaration) },\n                    { ALT: () => this.SUBRULE(this.SubDeclaration, Declaration) },\n                    { ALT: () => this.SUBRULE(this.ConditionalCompilationStatement, Declaration) },\n                    { ALT: () => this.SUBRULE(this.EmptyStatement, Declaration) },\n                    { ALT: () => this.SUBRULE(this.Comment, Declaration) }\n                ]);\n            });\n            this.OPTION(() => {\n                this.CONSUME(chevrotain_1.EOF);\n            });\n        }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "FunctionDeclaration",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "LibraryStatement",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "SubDeclaration",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "ConditionalCompilationStatement",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "EmptyStatement",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "Comment",
                    "idx": 0
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "EOF",
            "label": "EOF",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "BlockStatement",
    "orgText": "() => {\n            this.MANY(() => {\n                this.OR([{ ALT: () => this.SUBRULE(this.Statement, body) }, { ALT: () => this.CONSUME(Tokens_1.TERMINATOR) }]);\n            });\n        }",
    "definition": [
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "Statement",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "TERMINATOR",
                    "label": "TERMINATOR",
                    "idx": 0,
                    "pattern": "NOT_APPLICABLE"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Statement",
    "orgText": "() => {\n            this.OR2(this.cacheStatement ||\n                (this.cacheStatement = [\n                    { ALT: () => this.SUBRULE(this.EmptyStatement, Empty) },\n                    { ALT: () => this.SUBRULE(this.ForStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.IfStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.ForEachStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.WhileStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.PrintStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.ReturnStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.StopStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.GoToStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.LabeledStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.ConditionalCompilationStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.DimStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.NextStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.ExitStatement, Statement) },\n                    { ALT: () => this.SUBRULE(this.ExpressionStatement, Statement) }\n                ]));\n            this.OPTION(() => {\n                this.SUBRULE2(this.Comment, { LABEL: 'trailingComments' });\n            });\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 2,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "EmptyStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ForStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "IfStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ForEachStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "WhileStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "PrintStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ReturnStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "StopStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "GoToStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "LabeledStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ConditionalCompilationStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "DimStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "NextStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ExitStatement",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ExpressionStatement",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "Comment",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ArrayExpression",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.OPEN_BRACKET);\n            this.MANY(() => {\n                this.OR([\n                    { ALT: () => this.SUBRULE(this.ArrayElement, { LABEL: 'elements' }) },\n                    { ALT: () => this.CONSUME(Tokens_1.COMMA) },\n                    { ALT: () => this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' }) }\n                ]);\n            });\n            this.CONSUME(Tokens_1.CLOSE_BRACKET);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "OPEN_BRACKET",
        "label": "OPEN_BRACKET",
        "idx": 0,
        "pattern": "["
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "ArrayElement",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "COMMA",
                    "label": "COMMA",
                    "idx": 0,
                    "pattern": ","
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "EndOfStatement",
                    "idx": 0
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "CLOSE_BRACKET",
        "label": "CLOSE_BRACKET",
        "idx": 0,
        "pattern": "]"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ObjectExpression",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.OPEN_CURLY_BRACE);\n            this.MANY(() => {\n                this.OR([\n                    { ALT: () => this.SUBRULE(this.Property, { LABEL: 'properties' }) },\n                    { ALT: () => this.CONSUME(Tokens_1.COMMA) },\n                    { ALT: () => this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' }) }\n                ]);\n            });\n            this.CONSUME(Tokens_1.CLOSE_CURLY_BRACE);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "OPEN_CURLY_BRACE",
        "label": "OPEN_CURLY_BRACE",
        "idx": 0,
        "pattern": "{"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "Property",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "COMMA",
                    "label": "COMMA",
                    "idx": 0,
                    "pattern": ","
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "EndOfStatement",
                    "idx": 0
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "CLOSE_CURLY_BRACE",
        "label": "CLOSE_CURLY_BRACE",
        "idx": 0,
        "pattern": "}"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Property",
    "orgText": "() => {\n            this.SUBRULE(this.PropertyName, { LABEL: 'key' });\n            this.CONSUME(Tokens_1.COLON);\n            this.SUBRULE(this.AssignmentExpression, { LABEL: 'value' });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "PropertyName",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "COLON",
        "label": "COLON",
        "idx": 0,
        "pattern": ":"
      },
      {
        "type": "NonTerminal",
        "name": "AssignmentExpression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ArrayElement",
    "orgText": "() => {\n            this.SUBRULE(this.AssignmentExpression, { LABEL: 'value' });\n            this.OPTION(() => {\n                this.CONSUME(Tokens_1.COMMA);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "AssignmentExpression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "COMMA",
            "label": "COMMA",
            "idx": 0,
            "pattern": ","
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "PropertyName",
    "orgText": "() => {\n            this.OR([\n                { ALT: () => this.SUBRULE(this.Identifier) },\n                { ALT: () => this.SUBRULE(this.ReservedWord) },\n                { ALT: () => this.CONSUME(Tokens_1.STRING_LITERAL) },\n                { ALT: () => this.CONSUME(Tokens_1.NUMBER_LITERAL) }\n            ]);\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "Identifier",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ReservedWord",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "STRING_LITERAL",
                "label": "STRING_LITERAL",
                "idx": 0,
                "pattern": "\"([^\"]|\"\")*\""
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "NUMBER_LITERAL",
                "label": "NUMBER_LITERAL",
                "idx": 0,
                "pattern": "(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eEdD][-+]?\\d+)?"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "DimStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.DIM);\n            this.SUBRULE(this.Identifier);\n            this.SUBRULE(this.ArrayExpression);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "DIM",
        "label": "DIM",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "Identifier",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "ArrayExpression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "EmptyStatement",
    "orgText": "() => {\n            this.OPTION(() => {\n                this.SUBRULE2(this.Comment, { LABEL: 'trailingComments' });\n            });\n            this.CONSUME(Tokens_1.NEWLINE);\n        }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "Comment",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "NEWLINE",
        "label": "NEWLINE",
        "idx": 0,
        "pattern": "\\s*[\\n\\r]+"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ExitStatement",
    "orgText": "() => {\n            this.OR([\n                { ALT: () => this.CONSUME(Tokens_1.EXIT_WHILE) },\n                { ALT: () => this.CONSUME(Tokens_1.EXIT_FOR) }\n            ]);\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "EXIT_WHILE",
                "label": "EXIT_WHILE",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "EXIT_FOR",
                "label": "EXIT_FOR",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "IfStatement",
    "orgText": "() => {\n            let isBlock = false;\n            this.CONSUME(Tokens_1.IF);\n            this.SUBRULE1(this.ExpressionStatement, { LABEL: 'test' });\n            this.OPTION1(() => {\n                this.CONSUME(Tokens_1.THEN);\n            });\n            this.OPTION2(() => {\n                this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n                isBlock = true;\n            });\n            this.OPTION4(() => {\n                if (isBlock) {\n                    this.SUBRULE2(this.BlockStatement, { LABEL: 'consequent' });\n                }\n                else {\n                    this.SUBRULE2(this.Statement, { LABEL: 'consequent' });\n                }\n            });\n            this.MANY(() => {\n                this.SUBRULE(this.ElseIfStatement, { LABEL: 'alternate' });\n            });\n            this.OPTION5(() => {\n                this.SUBRULE(this.ElseStatement, { LABEL: 'alternate' });\n            });\n            this.OPTION6(() => {\n                this.CONSUME(Tokens_1.END_IF);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "IF",
        "label": "IF",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 1
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "Terminal",
            "name": "THEN",
            "label": "THEN",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "EndOfStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 4,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 2
          },
          {
            "type": "NonTerminal",
            "name": "Statement",
            "idx": 2
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ElseIfStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 5,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ElseStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 6,
        "definition": [
          {
            "type": "Terminal",
            "name": "END_IF",
            "label": "END_IF",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ElseIfStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.ELSE_IF);\n            this.SUBRULE(this.ExpressionStatement, { LABEL: 'test' });\n            this.OPTION1(() => {\n                this.CONSUME(Tokens_1.THEN);\n            });\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.OPTION5(() => {\n                this.SUBRULE2(this.BlockStatement, body);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "ELSE_IF",
        "label": "ELSE_IF",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "Terminal",
            "name": "THEN",
            "label": "THEN",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 5,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ElseStatement",
    "orgText": "() => {\n            let isBlock = false;\n            this.CONSUME(Tokens_1.ELSE);\n            this.OPTION1(() => {\n                this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n                isBlock = true;\n            });\n            this.OPTION2(() => {\n                if (isBlock) {\n                    this.SUBRULE2(this.BlockStatement, body);\n                }\n                else {\n                    this.SUBRULE2(this.Statement, body);\n                }\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "ELSE",
        "label": "ELSE",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "EndOfStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 2
          },
          {
            "type": "NonTerminal",
            "name": "Statement",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ForStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.FOR);\n            this.SUBRULE1(this.Identifier, { LABEL: 'counter' });\n            this.CONSUME(Tokens_1.EQUAL);\n            this.SUBRULE(this.AssignmentExpression, { LABEL: 'init' });\n            this.CONSUME(Tokens_1.TO);\n            this.SUBRULE2(this.ExpressionStatement, { LABEL: 'test' });\n            this.OPTION(() => {\n                this.CONSUME(Tokens_1.STEP);\n                this.SUBRULE3(this.ExpressionStatement, { LABEL: 'update' });\n            });\n            this.SUBRULE4(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.OPTION5(() => {\n                this.SUBRULE5(this.BlockStatement, body);\n            });\n            this.OPTION1(() => {\n                this.SUBRULE(this.NextStatement);\n            });\n            this.OPTION2(() => {\n                this.CONSUME(Tokens_1.END_FOR);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "FOR",
        "label": "FOR",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "Identifier",
        "idx": 1
      },
      {
        "type": "Terminal",
        "name": "EQUAL",
        "label": "EQUAL",
        "idx": 0,
        "pattern": "="
      },
      {
        "type": "NonTerminal",
        "name": "AssignmentExpression",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "TO",
        "label": "TO",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 2
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "STEP",
            "label": "STEP",
            "idx": 0
          },
          {
            "type": "NonTerminal",
            "name": "ExpressionStatement",
            "idx": 3
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 4
      },
      {
        "type": "Option",
        "idx": 5,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 5
          }
        ]
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "NextStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "END_FOR",
            "label": "END_FOR",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ForEachStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.FOR);\n            this.CONSUME(Tokens_1.EACH);\n            this.SUBRULE1(this.Identifier, { LABEL: 'counter' });\n            this.CONSUME(Tokens_1.IN);\n            this.SUBRULE2(this.ExpressionStatement, { LABEL: 'countExpression' });\n            this.SUBRULE3(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.SUBRULE(this.BlockStatement, body);\n            this.OPTION1(() => {\n                this.SUBRULE(this.NextStatement);\n            });\n            this.OPTION2(() => {\n                this.CONSUME(Tokens_1.END_FOR);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "FOR",
        "label": "FOR",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "EACH",
        "label": "EACH",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "Identifier",
        "idx": 1
      },
      {
        "type": "Terminal",
        "name": "IN",
        "label": "IN",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 2
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 3
      },
      {
        "type": "NonTerminal",
        "name": "BlockStatement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "NextStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "END_FOR",
            "label": "END_FOR",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "GoToStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.GOTO);\n            this.SUBRULE1(this.Identifier);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "GOTO",
        "label": "GOTO",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "Identifier",
        "idx": 1
      }
    ]
  },
  {
    "type": "Rule",
    "name": "LabeledStatement",
    "orgText": "() => {\n            this.SUBRULE(this.Identifier, { LABEL: 'label' });\n            this.CONSUME(Tokens_1.COLON);\n            this.CONSUME(Tokens_1.NEWLINE);\n            this.SUBRULE(this.Statement, { LABEL: 'body' });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "Identifier",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "COLON",
        "label": "COLON",
        "idx": 0,
        "pattern": ":"
      },
      {
        "type": "Terminal",
        "name": "NEWLINE",
        "label": "NEWLINE",
        "idx": 0,
        "pattern": "\\s*[\\n\\r]+"
      },
      {
        "type": "NonTerminal",
        "name": "Statement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "LibraryStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.LIBRARY);\n            this.CONSUME(Tokens_1.STRING_LITERAL, { LABEL: 'path' });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LIBRARY",
        "label": "LIBRARY",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "STRING_LITERAL",
        "label": "STRING_LITERAL",
        "idx": 0,
        "pattern": "\"([^\"]|\"\")*\""
      }
    ]
  },
  {
    "type": "Rule",
    "name": "NextStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.NEXT);\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "NEXT",
        "label": "NEXT",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "PrintStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.PRINT);\n            this.MANY(() => {\n                this.OR([\n                    { ALT: () => this.SUBRULE(this.ExpressionStatement, { LABEL: 'value' }) },\n                    { ALT: () => this.CONSUME(Tokens_1.COMMA) },\n                    { ALT: () => this.CONSUME(Tokens_1.SEMICOLON) }\n                ]);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "PRINT",
        "label": "PRINT",
        "idx": 0,
        "pattern": "NOT_APPLICABLE"
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Alternation",
            "idx": 0,
            "definition": [
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "NonTerminal",
                    "name": "ExpressionStatement",
                    "idx": 0
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "COMMA",
                    "label": "COMMA",
                    "idx": 0,
                    "pattern": ","
                  }
                ]
              },
              {
                "type": "Flat",
                "definition": [
                  {
                    "type": "Terminal",
                    "name": "SEMICOLON",
                    "label": "SEMICOLON",
                    "idx": 0,
                    "pattern": ";"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ReturnStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.RETURN);\n            this.OPTION1(() => {\n                this.SUBRULE(this.ExpressionStatement, { LABEL: 'argument' });\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "RETURN",
        "label": "RETURN",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ExpressionStatement",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "StopStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.STOP);\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "STOP",
        "label": "STOP",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "WhileStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.WHILE);\n            this.SUBRULE(this.ExpressionStatement, { LABEL: 'test' });\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.SUBRULE(this.BlockStatement, body);\n            this.CONSUME(Tokens_1.END_WHILE);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "WHILE",
        "label": "WHILE",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "BlockStatement",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "END_WHILE",
        "label": "END_WHILE",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "FunctionExpression",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.FUNCTION);\n            this.OPTION(() => {\n                this.SUBRULE(this.ParameterList, { LABEL: 'params' });\n            });\n            this.OPTION1(() => {\n                this.CONSUME(Tokens_1.AS);\n                this.SUBRULE(this.TypeAnnotation, { LABEL: 'ReturnType' });\n            });\n            this.OPTION2(() => {\n                this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            });\n            this.OPTION3(() => {\n                this.SUBRULE(this.BlockStatement, body);\n            });\n            this.CONSUME(Tokens_1.END_FUNCTION);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "FUNCTION",
        "label": "FUNCTION",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "Terminal",
            "name": "AS",
            "label": "AS",
            "idx": 0
          },
          {
            "type": "NonTerminal",
            "name": "TypeAnnotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "EndOfStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "END_FUNCTION",
        "label": "END_FUNCTION",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "FunctionDeclaration",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.FUNCTION);\n            this.SUBRULE(this.UnTypedIdentifier, { LABEL: 'id' });\n            this.OPTION(() => {\n                this.SUBRULE(this.ParameterList, { LABEL: 'params' });\n            });\n            this.OPTION1(() => {\n                this.CONSUME(Tokens_1.AS);\n                this.SUBRULE(this.TypeAnnotation, { LABEL: 'ReturnType' });\n            });\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.OPTION3(() => {\n                this.SUBRULE(this.BlockStatement, body);\n            });\n            this.CONSUME(Tokens_1.END_FUNCTION);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "FUNCTION",
        "label": "FUNCTION",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "UnTypedIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "Terminal",
            "name": "AS",
            "label": "AS",
            "idx": 0
          },
          {
            "type": "NonTerminal",
            "name": "TypeAnnotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "END_FUNCTION",
        "label": "END_FUNCTION",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "SubExpression",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.SUB);\n            this.OPTION(() => {\n                this.SUBRULE(this.ParameterList, { LABEL: 'params' });\n            });\n            this.OPTION1(() => {\n                this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            });\n            this.OPTION2(() => {\n                this.SUBRULE(this.BlockStatement, body);\n            });\n            this.CONSUME(Tokens_1.END_SUB);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "SUB",
        "label": "SUB",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "EndOfStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "END_SUB",
        "label": "END_SUB",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "SubDeclaration",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.SUB);\n            this.SUBRULE(this.UnTypedIdentifier, { LABEL: 'id' });\n            this.OPTION1(() => {\n                this.SUBRULE(this.ParameterList, { LABEL: 'params' });\n            });\n            this.OPTION2(() => {\n                this.CONSUME(Tokens_1.AS);\n                this.SUBRULE(this.TypeAnnotation, { LABEL: 'ReturnType' });\n            });\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.OPTION3(() => {\n                this.SUBRULE(this.BlockStatement, body);\n            });\n            this.CONSUME(Tokens_1.END_SUB);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "SUB",
        "label": "SUB",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "UnTypedIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ParameterList",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "Terminal",
            "name": "AS",
            "label": "AS",
            "idx": 0
          },
          {
            "type": "NonTerminal",
            "name": "TypeAnnotation",
            "idx": 0
          }
        ]
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "BlockStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "END_SUB",
        "label": "END_SUB",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ParameterList",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.OPEN_PAREN);\n            this.MANY_SEP({\n                SEP: Tokens_1.COMMA,\n                DEF() {\n                    this.SUBRULE2(this.Parameter);\n                }\n            });\n            this.CONSUME(Tokens_1.CLOSE_PAREN);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "OPEN_PAREN",
        "label": "OPEN_PAREN",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "RepetitionWithSeparator",
        "idx": 0,
        "separator": {
          "type": "Terminal",
          "name": "COMMA",
          "label": "COMMA",
          "idx": 1,
          "pattern": ","
        },
        "definition": [
          {
            "type": "NonTerminal",
            "name": "Parameter",
            "idx": 2
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "CLOSE_PAREN",
        "label": "CLOSE_PAREN",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Parameter",
    "orgText": "() => {\n            this.OR([\n                { ALT: () => this.SUBRULE(this.Literal) },\n                { ALT: () => this.SUBRULE(this.Identifier) },\n                { ALT: () => this.SUBRULE(this.ReservedWord) }\n            ]);\n            this.OPTION(() => {\n                this.OPTION1(() => {\n                    this.CONSUME(Tokens_1.EQUAL);\n                    this.SUBRULE(this.AssignmentExpression, { LABEL: 'value' });\n                });\n                this.OPTION2(() => {\n                    this.CONSUME(Tokens_1.AS);\n                    this.SUBRULE(this.TypeAnnotation);\n                });\n            });\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "Literal",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "Identifier",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ReservedWord",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Option",
            "idx": 1,
            "definition": [
              {
                "type": "Terminal",
                "name": "EQUAL",
                "label": "EQUAL",
                "idx": 0,
                "pattern": "="
              },
              {
                "type": "NonTerminal",
                "name": "AssignmentExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Option",
            "idx": 2,
            "definition": [
              {
                "type": "Terminal",
                "name": "AS",
                "label": "AS",
                "idx": 0
              },
              {
                "type": "NonTerminal",
                "name": "TypeAnnotation",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "TypeAnnotation",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.BASE_TYPE);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "BASE_TYPE",
        "label": "BASE_TYPE",
        "idx": 0,
        "pattern": "NOT_APPLICABLE"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ExpressionStatement",
    "orgText": "() => {\n            this.SUBRULE(this.AssignmentExpression);\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "AssignmentExpression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "AssignmentExpression",
    "orgText": "() => {\n            this.SUBRULE(this.AdditionExpression);\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "AdditionExpression",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "AdditionExpression",
    "orgText": "() => {\n            this.SUBRULE1(this.MultiplicationExpression, { LABEL: 'left' });\n            this.MANY(() => {\n                this.CONSUME(Tokens_1.ADDICTIVE_OPERATOR);\n                this.SUBRULE2(this.MultiplicationExpression, right);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "MultiplicationExpression",
        "idx": 1
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "ADDICTIVE_OPERATOR",
            "label": "ADDICTIVE_OPERATOR",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "MultiplicationExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "MultiplicationExpression",
    "orgText": "() => {\n            this.SUBRULE1(this.ShiftExpression, left);\n            this.MANY(() => {\n                this.CONSUME(Tokens_1.MULTI_OPERATOR);\n                this.SUBRULE2(this.ShiftExpression, right);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "ShiftExpression",
        "idx": 1
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "MULTI_OPERATOR",
            "label": "MULTI_OPERATOR",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "ShiftExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ShiftExpression",
    "orgText": "() => {\n            this.SUBRULE1(this.RelationExpression, left);\n            this.MANY(() => {\n                this.CONSUME(Tokens_1.SHIFT_OPERATOR);\n                this.SUBRULE2(this.RelationExpression, right);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "RelationExpression",
        "idx": 1
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "SHIFT_OPERATOR",
            "label": "SHIFT_OPERATOR",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "RelationExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "RelationExpression",
    "orgText": "() => {\n            this.SUBRULE1(this.EqualityExpression, left);\n            this.MANY(() => {\n                this.CONSUME(Tokens_1.RELATIONAL_OPERATOR);\n                this.SUBRULE2(this.EqualityExpression, right);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "EqualityExpression",
        "idx": 1
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "RELATIONAL_OPERATOR",
            "label": "RELATIONAL_OPERATOR",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "EqualityExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "EqualityExpression",
    "orgText": "() => {\n            this.SUBRULE1(this.LogicExpression, left);\n            this.MANY(() => {\n                this.CONSUME(Tokens_1.EQUALITY_OPERATOR);\n                this.SUBRULE2(this.LogicExpression, right);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "LogicExpression",
        "idx": 1
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "EQUALITY_OPERATOR",
            "label": "EQUALITY_OPERATOR",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "LogicExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "LogicExpression",
    "orgText": "() => {\n            this.SUBRULE1(this.UnaryExpression, left);\n            this.MANY(() => {\n                this.CONSUME(Tokens_1.LOGIC_OPERATOR);\n                this.SUBRULE2(this.UnaryExpression, right);\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "UnaryExpression",
        "idx": 1
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "LOGIC_OPERATOR",
            "label": "LOGIC_OPERATOR",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          },
          {
            "type": "NonTerminal",
            "name": "UnaryExpression",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "UnaryExpression",
    "orgText": "() => {\n            this.OR([\n                { ALT: () => this.SUBRULE(this.PostfixExpression) },\n                {\n                    ALT: () => {\n                        this.CONSUME(Tokens_1.UNARY);\n                        this.SUBRULE(this.UnaryExpression, right);\n                    }\n                }\n            ]);\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "PostfixExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "UNARY",
                "label": "UNARY",
                "idx": 0,
                "pattern": "NOT_APPLICABLE"
              },
              {
                "type": "NonTerminal",
                "name": "UnaryExpression",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Arguments",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.OPEN_PAREN);\n            this.MANY_SEP({\n                SEP: Tokens_1.COMMA,\n                DEF() {\n                    this.SUBRULE(this.AssignmentExpression, { LABEL: 'param' });\n                }\n            });\n            this.CONSUME(Tokens_1.CLOSE_PAREN);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "OPEN_PAREN",
        "label": "OPEN_PAREN",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "RepetitionWithSeparator",
        "idx": 0,
        "separator": {
          "type": "Terminal",
          "name": "COMMA",
          "label": "COMMA",
          "idx": 1,
          "pattern": ","
        },
        "definition": [
          {
            "type": "NonTerminal",
            "name": "AssignmentExpression",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "CLOSE_PAREN",
        "label": "CLOSE_PAREN",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "PostfixExpression",
    "orgText": "() => {\n            this.SUBRULE(this.MemberExpression, left);\n            this.OPTION(() => this.CONSUME(Tokens_1.POSTFIX));\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "MemberExpression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "POSTFIX",
            "label": "POSTFIX",
            "idx": 0,
            "pattern": "NOT_APPLICABLE"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "MemberExpression",
    "orgText": "() => {\n            this.SUBRULE(this.PrimaryExpression, { LABEL: 'id' });\n            this.OPTION1(() => this.SUBRULE1(this.Arguments, { LABEL: 'args' }));\n            this.MANY(() => {\n                this.SUBRULE(this.MemberChunkExpression, { LABEL: 'properties' });\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "PrimaryExpression",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 1,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "Arguments",
            "idx": 1
          }
        ]
      },
      {
        "type": "Repetition",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "MemberChunkExpression",
            "idx": 0
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "MemberChunkExpression",
    "orgText": "() => {\n            this.OR([\n                { ALT: () => this.SUBRULE(this.ArrayExpression, { LABEL: 'property' }) },\n                { ALT: () => this.SUBRULE(this.DotMemberExpression, { LABEL: 'property' }) }\n            ]);\n            this.OPTION2(() => this.SUBRULE2(this.Arguments, { LABEL: 'args' }));\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ArrayExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "DotMemberExpression",
                "idx": 0
              }
            ]
          }
        ]
      },
      {
        "type": "Option",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "Arguments",
            "idx": 2
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "DotMemberExpression",
    "orgText": "() => {\n            this.OR1([{ ALT: () => this.CONSUME(Tokens_1.PERIOD, operator) }, { ALT: () => this.CONSUME(Tokens_1.ATTRIBUTE, operator) }]);\n            this.OR2([\n                { ALT: () => this.SUBRULE(this.Identifier, right) },\n                { ALT: () => this.SUBRULE(this.ArrayExpression, right) },\n                { ALT: () => this.SUBRULE(this.ReservedWord, right) }\n            ]);\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 1,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "PERIOD",
                "label": "PERIOD",
                "idx": 0,
                "pattern": "."
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "ATTRIBUTE",
                "label": "ATTRIBUTE",
                "idx": 0,
                "pattern": "@"
              }
            ]
          }
        ]
      },
      {
        "type": "Alternation",
        "idx": 2,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "Identifier",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ArrayExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ReservedWord",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "PrimaryExpression",
    "orgText": "() => {\n            this.OR(this.cachePrimaryExpression ||\n                (this.cachePrimaryExpression = [\n                    { ALT: () => this.SUBRULE(this.ArrayExpression) },\n                    { ALT: () => this.SUBRULE(this.ObjectExpression) },\n                    { ALT: () => this.SUBRULE(this.FunctionExpression) },\n                    { ALT: () => this.SUBRULE(this.SubExpression) },\n                    { ALT: () => this.SUBRULE(this.ParenthesisExpression) },\n                    { ALT: () => this.SUBRULE(this.Identifier) },\n                    { ALT: () => this.SUBRULE(this.ReservedWord) },\n                    { ALT: () => this.SUBRULE(this.Literal) }\n                ]));\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ArrayExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ObjectExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "FunctionExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "SubExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ParenthesisExpression",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "Identifier",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ReservedWord",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "Literal",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ParenthesisExpression",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.OPEN_PAREN);\n            this.SUBRULE(this.ExpressionStatement, { LABEL: 'innerExpression' });\n            this.CONSUME(Tokens_1.CLOSE_PAREN);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "OPEN_PAREN",
        "label": "OPEN_PAREN",
        "idx": 0,
        "pattern": "("
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 0
      },
      {
        "type": "Terminal",
        "name": "CLOSE_PAREN",
        "label": "CLOSE_PAREN",
        "idx": 0,
        "pattern": ")"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Literal",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.LITERAL);\n            this.OPTION(() => {\n                this.CONSUME(Tokens_1.TYPE_DECLARATION);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "LITERAL",
        "label": "LITERAL",
        "idx": 0,
        "pattern": "NOT_APPLICABLE"
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "TYPE_DECLARATION",
            "label": "TYPE_DECLARATION",
            "idx": 0,
            "pattern": "[\\$%!#&]"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "UnTypedIdentifier",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.IDENTIFIER);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "IDENTIFIER",
        "label": "IDENTIFIER",
        "idx": 0,
        "pattern": "([A-Za-z_]+[A-Za-z0-9_]*)"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Identifier",
    "orgText": "() => {\n            this.SUBRULE(this.UnTypedIdentifier, { LABEL: 'id' });\n            this.OPTION(() => {\n                this.CONSUME(Tokens_1.TYPE_DECLARATION, { LABEL: 'asType' });\n            });\n        }",
    "definition": [
      {
        "type": "NonTerminal",
        "name": "UnTypedIdentifier",
        "idx": 0
      },
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "Terminal",
            "name": "TYPE_DECLARATION",
            "label": "TYPE_DECLARATION",
            "idx": 0,
            "pattern": "[\\$%!#&]"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ReservedWord",
    "orgText": "() => {\n            this.OR(this.cacheReservedWord ||\n                (this.cacheReservedWord = [\n                    { ALT: () => this.CONSUME(Tokens_1.END) },\n                    { ALT: () => this.CONSUME(Tokens_1.IN) },\n                    { ALT: () => this.CONSUME(Tokens_1.MOD) },\n                    { ALT: () => this.CONSUME(Tokens_1.OBJECT) },\n                    { ALT: () => this.CONSUME(Tokens_1.STOP) },\n                    { ALT: () => this.CONSUME(Tokens_1.NEXT) },\n                    { ALT: () => this.CONSUME(Tokens_1.BOOLEAN) },\n                    { ALT: () => this.CONSUME(Tokens_1.INTEGER) },\n                    { ALT: () => this.CONSUME(Tokens_1.LONGINTEGER) },\n                    { ALT: () => this.CONSUME(Tokens_1.STRING) }\n                ]));\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "END",
                "label": "END",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "IN",
                "label": "IN",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "MOD",
                "label": "MOD",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "OBJECT",
                "label": "OBJECT",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "STOP",
                "label": "STOP",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "NEXT",
                "label": "NEXT",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "BOOLEAN",
                "label": "BOOLEAN",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "INTEGER",
                "label": "INTEGER",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "LONGINTEGER",
                "label": "LONGINTEGER",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "STRING",
                "label": "STRING",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ConditionalCompilationStatement",
    "orgText": "() => {\n            this.OR(this.cacheConditionalCompilationStatement ||\n                (this.cacheConditionalCompilationStatement = [\n                    { ALT: () => this.SUBRULE(this.ConditionalConst) },\n                    { ALT: () => this.SUBRULE(this.ConditionalError) },\n                    { ALT: () => this.SUBRULE(this.ConditionalIfStatement) }\n                ]));\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ConditionalConst",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ConditionalError",
                "idx": 0
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "NonTerminal",
                "name": "ConditionalIfStatement",
                "idx": 0
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ConditionalConst",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.CONDITIONAL_CONST);\n            this.SUBRULE(this.ExpressionStatement, { LABEL: 'assignment' });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "CONDITIONAL_CONST",
        "label": "CONDITIONAL_CONST",
        "idx": 0,
        "pattern": "#\\bconst\\b"
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 0
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ConditionalError",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.CONDITIONAL_ERROR);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "CONDITIONAL_ERROR",
        "label": "CONDITIONAL_ERROR",
        "idx": 0,
        "pattern": "#\\berror\\b[^\\n\\r]+"
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ConditionalIfStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.CONDITIONAL_IF);\n            this.SUBRULE1(this.ExpressionStatement, { LABEL: 'test' });\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.SUBRULE2(this.BlockStatement, body);\n            this.MANY2(() => {\n                this.SUBRULE(this.ConditionalElseIfStatement, { LABEL: 'alternate' });\n            });\n            this.OPTION3(() => {\n                this.SUBRULE(this.ConditionalElseStatement, { LABEL: 'alternate' });\n            });\n            this.OPTION4(() => {\n                this.CONSUME(Tokens_1.CONDITIONAL_END_IF);\n            });\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "CONDITIONAL_IF",
        "label": "CONDITIONAL_IF",
        "idx": 0,
        "pattern": "#\\bif\\b"
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 1
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "BlockStatement",
        "idx": 2
      },
      {
        "type": "Repetition",
        "idx": 2,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ConditionalElseIfStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 3,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "ConditionalElseStatement",
            "idx": 0
          }
        ]
      },
      {
        "type": "Option",
        "idx": 4,
        "definition": [
          {
            "type": "Terminal",
            "name": "CONDITIONAL_END_IF",
            "label": "CONDITIONAL_END_IF",
            "idx": 0,
            "pattern": "#\\bend[ ]*if\\b"
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ConditionalElseIfStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.CONDITIONAL_ELSE_IF);\n            this.SUBRULE(this.ExpressionStatement, { LABEL: 'test' });\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.SUBRULE2(this.BlockStatement, body);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "CONDITIONAL_ELSE_IF",
        "label": "CONDITIONAL_ELSE_IF",
        "idx": 0,
        "pattern": "#\\belse[ ]*if\\b"
      },
      {
        "type": "NonTerminal",
        "name": "ExpressionStatement",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "BlockStatement",
        "idx": 2
      }
    ]
  },
  {
    "type": "Rule",
    "name": "ConditionalElseStatement",
    "orgText": "() => {\n            this.CONSUME(Tokens_1.CONDITIONAL_ELSE);\n            this.SUBRULE(this.EndOfStatement, { LABEL: 'trailingComments' });\n            this.SUBRULE2(this.BlockStatement, body);\n        }",
    "definition": [
      {
        "type": "Terminal",
        "name": "CONDITIONAL_ELSE",
        "label": "CONDITIONAL_ELSE",
        "idx": 0,
        "pattern": "#\\else\\b"
      },
      {
        "type": "NonTerminal",
        "name": "EndOfStatement",
        "idx": 0
      },
      {
        "type": "NonTerminal",
        "name": "BlockStatement",
        "idx": 2
      }
    ]
  },
  {
    "type": "Rule",
    "name": "Comment",
    "orgText": "() => {\n            this.OR([\n                { ALT: () => this.CONSUME(Tokens_1.COMMENT_QUOTE) },\n                { ALT: () => this.CONSUME(Tokens_1.COMMENT_REM) }\n            ]);\n        }",
    "definition": [
      {
        "type": "Alternation",
        "idx": 0,
        "definition": [
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "COMMENT_QUOTE",
                "label": "COMMENT_QUOTE",
                "idx": 0,
                "pattern": "'[^\\n\\r]*"
              }
            ]
          },
          {
            "type": "Flat",
            "definition": [
              {
                "type": "Terminal",
                "name": "COMMENT_REM",
                "label": "COMMENT_REM",
                "idx": 0,
                "pattern": "\\b(rem|REM|Rem)\\b[^\\n\\r]*"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Rule",
    "name": "EndOfStatement",
    "orgText": "() => {\n            this.OPTION(() => {\n                this.SUBRULE(this.Comment);\n            });\n            this.CONSUME(Tokens_1.TERMINATOR);\n        }",
    "definition": [
      {
        "type": "Option",
        "idx": 0,
        "definition": [
          {
            "type": "NonTerminal",
            "name": "Comment",
            "idx": 0
          }
        ]
      },
      {
        "type": "Terminal",
        "name": "TERMINATOR",
        "label": "TERMINATOR",
        "idx": 0,
        "pattern": "NOT_APPLICABLE"
      }
    ]
  }
];
</script>

<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
</script>
